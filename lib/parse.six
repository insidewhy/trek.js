module _ = 'underscore'

////////////////////////////////////////////////////////////////////////////
// base parse classes
class StoresChar {
  constructor() {
    this.stores = char
  }

  skip(stream) {
    if (! this.match(stream))
      return false
    stream.inc()
    return true
  }
}

class StoresString {
  constructor() {
    this.stores = String
  }

  parse(stream) {
    var first = stream.idx
    if (this.skip(stream)) {
      return stream.from(first)
    }
    else {
      stream.idx = first
      return null
    }
  }
}

class Node {
  constructor(stream, type) {
    this.range = [ stream.idx ]
    this.type = type
  }

  end(stream) {
    this.range.push(stream.idx)
    return this
  }
}

//////////////////////////////////////////////////////////////////////////////
// Skip classes
class SkipString extends StoresString {
  constructor() {
    super()
    this.skips = true
    this.parsers = []
  }

  skip(stream) {
    var first = stream.idx
    if (_.find(this.parsers, p => ! p.skip(stream))) {
      stream.idx = first
      return false
    }
    return true
  }
}

//////////////////////////////////////////////////////////////////////////////
// Parse classes
class ParseRange extends StoresChar {
  constructor(range) {
    super()
    this.from = range[0]
    this.to = range[1]
  }

  match(stream) {
    return stream.front >= this.from && stream.front <= this.to
  }
}

class ParseMany {
  constructor(atLeastOne) {
    this.atLeastOne = atLeastOne
  }
}

class ParseManyChar extends StoresString {
  constructor(atLeastOne, parser) {
    super()
    this.atLeastOne = atLeastOne
    this.parser = parser
  }

  skip(stream) {
    if (! this.parser.skip(stream))
      return this.atLeastOne
    while (this.parser.skip(stream)) {}
    return true
  }
}

//////////////////////////////////////////////////////////////////////////////
// node parsers
class ParseNode {
  constructor(type, parser) {
    this.type = type
    this.parser = parser
  }

  parse(stream) {
    var node = new Node(stream, this.type),
        backup = stream.node

    stream.node = node
    var ret = this.parser.parse(stream)
    stream.node = backup

    return ret && node.end(stream)
  }
}

class ParseMember {
  constructor(name, parser) {
    this.name = name
    this.parser = parser
  }

  parse(stream) {
    var ast = this.parser.parse(stream)
    return ast && (stream.node[this.name] = ast)
  }
}

////////////////////////////////////////////////////////////////////////////
// helper function
function makeSeq(args, offset) {
  if (! offset)
    offset = 0

  if (offset + 1 == args.length)
    return args[offset]
  else
    return sequence.apply(this, [].slice.call(args, offset))
}

////////////////////////////////////////////////////////////////////////////
// public factory functions

// Makes any parser act like a char parser such that it will be combined
// into ranges by parent parsers as if it was storing only a single character.
export function char() {
  var parser = makeSeq(arguments)
  parser.stores = char
  return parser
}

// Parse any character that falls in between two other characters inclusive.
export function range(charRange) {
  return new ParseRange(charRange)
}

export function star() { return many(false, makeSeq(arguments)) }
export function plus() { return many(true, makeSeq(arguments)) }

export function many() {
  var atLeastOne = arguments[0],
      parser     = makeSeq(arguments, 1)

  return parser.stores === char ?
    new ParseManyChar(atLeastOne, parser) : new ParseMany(atLeastOne, parser)
}

export function lexeme() {
  var parser, parsers = [].slice.call(arguments, 0)

  var canBeJoined = p => p.stores === char || p.stores === String
  var skipper

  var lexParsers = []

  // try to join string/char storing parsers together into longer
  // string storing parsers
  for (var i = 0; i < parsers.length - 1; ++i) {
    parser = parsers[i]
    if (canBeJoined(parser) && canBeJoined(parsers[i + 1])) {
      parsers[i] = skipper = new SkipString()
      skipper.parsers.push(parser)
      skipper.parsers.push(parsers[i + 1])

      parsers.splice(++i, 1)

      while (i < parsers.length) {
        parser = parsers[i]
        if (! canBeJoined(parser))
          break

        skipper.parsers.push(parser)
        parsers.shift()
      }
    }
  }

  // TODO: return parser that parses all components of lexeme in a row
  return parsers[0]
}

export function or() {
}

//////////////////////////////////////////////////////////////////////////////
// node stuff
export function node() {
  var type   = arguments[0]
  return new ParseNode(type, makeSeq(arguments, 1))
}

export function member() {
  var name   = arguments[0]
  return new ParseMember(name, makeSeq(arguments, 1))
}

//////////////////////////////////////////////////////////////////////////////
// stream stuff
class Stream {
  constructor(spacing) {
    this.spacing = spacing
  }

  inc() { ++this.idx }

  from(idx) {
    return this.source.substring(idx, this.idx - idx)
  }

  get front() { return this.source[this.idx] }

  parse(grammar, source) {
    this.idx = 0
    this.source = source

    // TODO: first skip whitepace

    // parse grammar
    var ast = grammar.parse(this)

    // TODO: skip whitespace
    // TODO: confirm is at end

    return ast
  }
}

export var stream = spacing => new Stream(spacing)

export var parse = (spacing, grammar, src) =>
  stream(spacing).parse(grammar, src)
